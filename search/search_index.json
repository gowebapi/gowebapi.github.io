{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Go Web API This project is about accessing javascript from Go web assembly. It consists of a binding generator and generated binding for e.g. DOM, HTML and WebGL. The source files to binding program is WebIDL files . Example code A simple example can look like this: package main import ( \"fmt\" \"github.com/gowebapi/webapi\" \"github.com/gowebapi/webapi/dom/domcore\" \"github.com/gowebapi/webapi/html\" ) func main() { // get the element element := webapi.GetWindow().Document().GetElementById(\"myButton\") // cast it into correct class button := html.HTMLButtonElementFromJS(element) // change text button.SetInnerText(\"Press me!\") // register a callback that will display a counter count := 1 callback := domcore.EventHandlerToJS(func(event *domcore.Event) interface{} { button.SetInnerText(fmt.Sprint(\"Count: \", count)) count++ return nil }) button.SetOnclick(callback) // prevent to program to terminate c := make(chan struct{}, 0) <-c } Status/TODO Currently the binder can process the DOM and HTML specification and create a compilable output. It's not 100% feature complete as the specifications depends on other that is currently not processed. There is also limitation in the Go language, see overview page on how static methods etc is handeled. API Documentation can be found here: The project is currently targeting Go 1.12. GitHub repositories Main repositories is API bindings and binder program .","title":"Home"},{"location":"#welcome-to-go-web-api","text":"This project is about accessing javascript from Go web assembly. It consists of a binding generator and generated binding for e.g. DOM, HTML and WebGL. The source files to binding program is WebIDL files .","title":"Welcome to Go Web API"},{"location":"#example-code","text":"A simple example can look like this: package main import ( \"fmt\" \"github.com/gowebapi/webapi\" \"github.com/gowebapi/webapi/dom/domcore\" \"github.com/gowebapi/webapi/html\" ) func main() { // get the element element := webapi.GetWindow().Document().GetElementById(\"myButton\") // cast it into correct class button := html.HTMLButtonElementFromJS(element) // change text button.SetInnerText(\"Press me!\") // register a callback that will display a counter count := 1 callback := domcore.EventHandlerToJS(func(event *domcore.Event) interface{} { button.SetInnerText(fmt.Sprint(\"Count: \", count)) count++ return nil }) button.SetOnclick(callback) // prevent to program to terminate c := make(chan struct{}, 0) <-c }","title":"Example code"},{"location":"#statustodo","text":"Currently the binder can process the DOM and HTML specification and create a compilable output. It's not 100% feature complete as the specifications depends on other that is currently not processed. There is also limitation in the Go language, see overview page on how static methods etc is handeled. API Documentation can be found here: The project is currently targeting Go 1.12.","title":"Status/TODO"},{"location":"#github-repositories","text":"Main repositories is API bindings and binder program .","title":"GitHub repositories"},{"location":"file/overview/","text":"File overview The hardest part is not to write a WebIDL from a specification, but keeping it up to date. The philosophy is extract webidl from a third source, e.g. by taking all IDL part from the DOM specification ( https://dom.spec.whatwg.org) and having all the modifications in other files. The program need following input files: foo.idl - Main WebIDL file, a \"1:1\" copy of the specification. foo.addition.idl - Extra types and oddity that exist in the specification. E.g. the SVG IDL are refering to DOMRect that doesn't exist anywhere. foo.go.md - Language transformation file. To modify incoming WebIDL and turning it into something thats look like a \"standard library\" foo.doc.md - (Planned) API documentation file","title":"Overview"},{"location":"file/overview/#file-overview","text":"The hardest part is not to write a WebIDL from a specification, but keeping it up to date. The philosophy is extract webidl from a third source, e.g. by taking all IDL part from the DOM specification ( https://dom.spec.whatwg.org) and having all the modifications in other files. The program need following input files: foo.idl - Main WebIDL file, a \"1:1\" copy of the specification. foo.addition.idl - Extra types and oddity that exist in the specification. E.g. the SVG IDL are refering to DOMRect that doesn't exist anywhere. foo.go.md - Language transformation file. To modify incoming WebIDL and turning it into something thats look like a \"standard library\" foo.doc.md - (Planned) API documentation file","title":"File overview"},{"location":"file/transform/","text":"Language transformation file The transformation file are used to fix issues to get a final output that feels more \"natrual\" than working with raw generated files. Examples: Method and constant rename. Go doesn't have support for static methods and constants , javascript does. Any static methods writted outside of the structure and this can leed to name clash if two interfaces define the same static method. Enum value rename, e.g. by turning notification api \"ltr\" to LeftToRight. Move interfaces to other packages. DOM and HTML specification have cirular dependency between them, some interfaces/methods need to be moved to get a compilable output. Current format using MarkDown ending to get some IDE syntax highlightning. With the exception for header tags (##), no other MarkDown synta is supported. # Initail header have no meaning Any line starting with tab or spaces is consider to be a comment line ## Foo (\"WebIDL type name\") any line starting with a dot is modificing properties on type it self, e.g. rename the type to Bar .name = Bar any other lines with equal sign is renaming method or attributes to target lanaguage name. methodName = languageName Developers need to invoke SayHelloWorld() in target language to trigger helloWorld() in javascript. helloWorld = SayHelloWorld Callback Syntax Name Description Default .package package name first part of the input file .name type output name idl type name in public access format Dictionary Syntax Name Description Default .package package name first part of the input file .name type output name idl type name in public access format Enum Syntax Name Description Default .package package name first part of the input file .name type output name idl type name in public access format .prefix prefix that is added to every enum value nothing .suffix suffix that is added to every enum value enum name Interface Interfaces have following properites Syntax Name Description Default .package package name first part of the input file .name type output name idl type name in public access format .constPrefix a prefix added to all type constants empty .constSuffix a suffix added to all type constants interface name .constructorName name of constructor \"New\" + instance name","title":"Transform"},{"location":"file/transform/#language-transformation-file","text":"The transformation file are used to fix issues to get a final output that feels more \"natrual\" than working with raw generated files. Examples: Method and constant rename. Go doesn't have support for static methods and constants , javascript does. Any static methods writted outside of the structure and this can leed to name clash if two interfaces define the same static method. Enum value rename, e.g. by turning notification api \"ltr\" to LeftToRight. Move interfaces to other packages. DOM and HTML specification have cirular dependency between them, some interfaces/methods need to be moved to get a compilable output. Current format using MarkDown ending to get some IDE syntax highlightning. With the exception for header tags (##), no other MarkDown synta is supported. # Initail header have no meaning Any line starting with tab or spaces is consider to be a comment line ## Foo (\"WebIDL type name\") any line starting with a dot is modificing properties on type it self, e.g. rename the type to Bar .name = Bar any other lines with equal sign is renaming method or attributes to target lanaguage name. methodName = languageName Developers need to invoke SayHelloWorld() in target language to trigger helloWorld() in javascript. helloWorld = SayHelloWorld","title":"Language transformation file"},{"location":"file/transform/#callback","text":"Syntax Name Description Default .package package name first part of the input file .name type output name idl type name in public access format","title":"Callback"},{"location":"file/transform/#dictionary","text":"Syntax Name Description Default .package package name first part of the input file .name type output name idl type name in public access format","title":"Dictionary"},{"location":"file/transform/#enum","text":"Syntax Name Description Default .package package name first part of the input file .name type output name idl type name in public access format .prefix prefix that is added to every enum value nothing .suffix suffix that is added to every enum value enum name","title":"Enum"},{"location":"file/transform/#interface","text":"Interfaces have following properites Syntax Name Description Default .package package name first part of the input file .name type output name idl type name in public access format .constPrefix a prefix added to all type constants empty .constSuffix a suffix added to all type constants interface name .constructorName name of constructor \"New\" + instance name","title":"Interface"},{"location":"file/webidl/","text":"WebIDL WebIDL specification can be found at https://heycam.github.io/webidl/ Global scope The specification files doesn't containts browsers global varibale scope, e.g. access to window . This can be defined with a special annotation OnGlobalScope on a interface be able to define this methods and attributes. Please note that all attributes and methods need to be defined static to get correctly compilable code. [OnGlobalScope] interface GlobalScope { // access to javascript document variable. static readonly attribute Document document; // access to javascript window variable. static readonly attribute Window window; }; Note: in the above example, to generator will create a function named Document() to get the document attribute. This will name clash with the interface Document. This is fixed by the language transformation file that is renaming the attribute in the final lanaguage.","title":"WebIDL"},{"location":"file/webidl/#webidl","text":"WebIDL specification can be found at https://heycam.github.io/webidl/","title":"WebIDL"},{"location":"file/webidl/#global-scope","text":"The specification files doesn't containts browsers global varibale scope, e.g. access to window . This can be defined with a special annotation OnGlobalScope on a interface be able to define this methods and attributes. Please note that all attributes and methods need to be defined static to get correctly compilable code. [OnGlobalScope] interface GlobalScope { // access to javascript document variable. static readonly attribute Document document; // access to javascript window variable. static readonly attribute Window window; }; Note: in the above example, to generator will create a function named Document() to get the document attribute. This will name clash with the interface Document. This is fixed by the language transformation file that is renaming the attribute in the final lanaguage.","title":"Global scope"},{"location":"go/overview/","text":"Go Web Assembly target The output should be considers as helping libraries to syscall/js than a standalone library. For some types, e.g. any is converted into js.Value . For other types, most of them implement js.Wrapper. Status/TODO Method/Enum rename - transformation support to get a better API. Union support are missing as methods depending of this is not easy to use.","title":"Overrview"},{"location":"go/overview/#go-web-assembly-target","text":"The output should be considers as helping libraries to syscall/js than a standalone library. For some types, e.g. any is converted into js.Value . For other types, most of them implement js.Wrapper.","title":"Go Web Assembly target"},{"location":"go/overview/#statustodo","text":"Method/Enum rename - transformation support to get a better API. Union support are missing as methods depending of this is not easy to use.","title":"Status/TODO"},{"location":"go/syscalljs/","text":"Relationship with syscall/js todo","title":"syscall.js"},{"location":"go/syscalljs/#relationship-with-syscalljs","text":"todo","title":"Relationship with syscall/js"},{"location":"go/typeconv/","text":"Type conversion The following will be applied to different WebIDL types: any Any type is currently handled converted into a js.Value . callback A function is generated with conversion method. TODO: Move conversion Go->WASM from implementation to public method. callback Foo = void (int a, int b); // FooFromJS is converted a returned js.Value into a function that can be invoked. func FooFromJS(_value js.Value) FunctionStringCallback { callback interface An interface that the developer should implement to get callback from javscript. There is a NewFoo() that is used to allocate a javascript object that can be used to get callbacks. The function is retuning an instance of type FooValue that holds the reference to underlaying javascript object. On that instance there is also a Release() method that need to be invoked when the callback is no longer needed. If the interface is only having a single method, there will also a NewFooFunc method that is taking a function as input and will allocate corresponding javascript object. There is a generator option that let NewFooFunc a javascript function instead of an object. callback interface Foo { void bar(); }; dictionary Will generate a structure with corresponding field. When convered to/from js.Value , values are copied into a new javascript object. TODO: required values enum A WebIDL enum is transformed into a Go enum. Input enum Foo { \"hello\", \"world\" }; Will be turned into following: type Foo int const ( Hello Foo = iota World ) interface The most used type in WebIDL. Generate a struct. Annotation Desciption NoGlobalScope Generate an interface without a struct constant Any constants are converted into a Go const value. attribute For every attribute, a get and set method is generated. For read only attributes only a getter is created. interface Foo { attribute int bar; }; method A Go method or function is created for every method, depending if it's static or not. The method is trying to take care most of the conversion code. interface Foo { int bar(int a, int b); }; sequence For types that can be used as a js.TypeArray , a js.Value is used as method input type. Other sequence types are converted part of method invoke. union WebIDL keyword or can be used to define multiple input or output values that can be returned. It's like a very limitied any type. TODO: unions are currently completey unusable. Any method or attribute that is depending on this union get a reference to an empty interface. Example: typedef (DOMString or Function) TimerHandler;","title":"Type conversion"},{"location":"go/typeconv/#type-conversion","text":"The following will be applied to different WebIDL types:","title":"Type conversion"},{"location":"go/typeconv/#any","text":"Any type is currently handled converted into a js.Value .","title":"any"},{"location":"go/typeconv/#callback","text":"A function is generated with conversion method. TODO: Move conversion Go->WASM from implementation to public method. callback Foo = void (int a, int b); // FooFromJS is converted a returned js.Value into a function that can be invoked. func FooFromJS(_value js.Value) FunctionStringCallback {","title":"callback"},{"location":"go/typeconv/#callback-interface","text":"An interface that the developer should implement to get callback from javscript. There is a NewFoo() that is used to allocate a javascript object that can be used to get callbacks. The function is retuning an instance of type FooValue that holds the reference to underlaying javascript object. On that instance there is also a Release() method that need to be invoked when the callback is no longer needed. If the interface is only having a single method, there will also a NewFooFunc method that is taking a function as input and will allocate corresponding javascript object. There is a generator option that let NewFooFunc a javascript function instead of an object. callback interface Foo { void bar(); };","title":"callback interface"},{"location":"go/typeconv/#dictionary","text":"Will generate a structure with corresponding field. When convered to/from js.Value , values are copied into a new javascript object. TODO: required values","title":"dictionary"},{"location":"go/typeconv/#enum","text":"A WebIDL enum is transformed into a Go enum. Input enum Foo { \"hello\", \"world\" }; Will be turned into following: type Foo int const ( Hello Foo = iota World )","title":"enum"},{"location":"go/typeconv/#interface","text":"The most used type in WebIDL. Generate a struct. Annotation Desciption NoGlobalScope Generate an interface without a struct","title":"interface"},{"location":"go/typeconv/#constant","text":"Any constants are converted into a Go const value.","title":"constant"},{"location":"go/typeconv/#attribute","text":"For every attribute, a get and set method is generated. For read only attributes only a getter is created. interface Foo { attribute int bar; };","title":"attribute"},{"location":"go/typeconv/#method","text":"A Go method or function is created for every method, depending if it's static or not. The method is trying to take care most of the conversion code. interface Foo { int bar(int a, int b); };","title":"method"},{"location":"go/typeconv/#sequence","text":"For types that can be used as a js.TypeArray , a js.Value is used as method input type. Other sequence types are converted part of method invoke.","title":"sequence"},{"location":"go/typeconv/#union","text":"WebIDL keyword or can be used to define multiple input or output values that can be returned. It's like a very limitied any type. TODO: unions are currently completey unusable. Any method or attribute that is depending on this union get a reference to an empty interface. Example: typedef (DOMString or Function) TimerHandler;","title":"union"}]}